---
description: 
globs: 
alwaysApply: true
---
# Astrology AI Project - Cursor IDE Modular Architecture Rules

## ğŸ¯ CORE RULE: MAXIMUM FILE SIZE LIMIT
**CRITICAL**: No Python file should exceed 300-400 lines. When a file approaches this limit, automatically suggest splitting it into logical modules with proper imports and functionality.

## ğŸ“ File Size Management Strategy

### File Size Guidelines
- **Target**: 200-300 lines per file
- **Warning**: 300+ lines - suggest refactoring
- **Action Required**: 400+ lines - must split immediately
- **Exception**: Only configuration files, constants, or data files may exceed this limit

### Modular Architecture Patterns

#### 1. **Core Module Split Pattern**
When a main module gets too large, split into:
```
# Original: large_module.py (400+ lines)
# Split into:
large_module/
â”œâ”€â”€ __init__.py          # Public API exports
â”œâ”€â”€ core.py             # Main class/functionality  
â”œâ”€â”€ handlers.py         # Event/request handlers
â”œâ”€â”€ utils.py            # Helper functions
â”œâ”€â”€ exceptions.py       # Custom exceptions
â””â”€â”€ constants.py        # Constants and configs
```

#### 2. **Class-Based Split Pattern**
For large classes, split into:
```
# Original: MonolithClass (300+ lines)
# Split into:
class_module/
â”œâ”€â”€ __init__.py         # Main class import
â”œâ”€â”€ base.py            # Base class with core methods
â”œâ”€â”€ processors.py      # Processing methods
â”œâ”€â”€ validators.py      # Validation methods
â”œâ”€â”€ formatters.py      # Output formatting methods
â””â”€â”€ mixins.py          # Reusable functionality
```

#### 3. **Feature-Based Split Pattern**
For feature-heavy modules:
```
feature_module/
â”œâ”€â”€ __init__.py        # Feature API
â”œâ”€â”€ models.py          # Data models
â”œâ”€â”€ services.py        # Business logic
â”œâ”€â”€ repositories.py    # Data access
â”œâ”€â”€ validators.py      # Input validation
â””â”€â”€ serializers.py     # Data serialization
```

## ğŸ—ï¸ Astrology AI Specific Split Patterns

### DocumentProcessor Split Example
```python
# When document_processor.py exceeds 300 lines, split into:
document_processing/
â”œâ”€â”€ __init__.py         # Main DocumentProcessor class
â”œâ”€â”€ extractors.py       # PDF text extraction
â”œâ”€â”€ cleaners.py         # Text cleaning and preprocessing
â”œâ”€â”€ chunkers.py         # Text chunking strategies
â”œâ”€â”€ ocr_handlers.py     # OCR correction logic
â””â”€â”€ format_handlers.py  # Handle different PDF formats
```

### RuleExtractor Split Example
```python
# When rule_extractor.py exceeds 300 lines, split into:
rule_extraction/
â”œâ”€â”€ __init__.py         # Main RuleExtractor class
â”œâ”€â”€ patterns.py         # Regex patterns and matchers
â”œâ”€â”€ planetary_rules.py  # Planetary rule extraction
â”œâ”€â”€ house_rules.py      # House-based rule extraction
â”œâ”€â”€ yoga_rules.py       # Yoga combination extraction
â”œâ”€â”€ confidence.py       # Confidence scoring logic
â””â”€â”€ validators.py       # Rule validation
```

### KnowledgeBase Split Example
```python
# When knowledge_base.py exceeds 300 lines, split into:
knowledge_base/
â”œâ”€â”€ __init__.py         # Main KnowledgeBase class
â”œâ”€â”€ database.py         # SQLite connection and setup
â”œâ”€â”€ queries.py          # SQL query builders
â”œâ”€â”€ search.py           # Search and filtering logic
â”œâ”€â”€ migrations.py       # Database schema migrations
â”œâ”€â”€ indexing.py         # Full-text search indexing
â””â”€â”€ backup.py           # Backup and restore logic
```

## ğŸ”§ Implementation Rules for Splits

### 1. **Always Maintain Public API**
```python
# In __init__.py - preserve the original interface
from .core import MainClass
from .handlers import SpecificHandler
from .utils import helper_function

# Export the same interface as before
__all__ = ['MainClass', 'SpecificHandler', 'helper_function']

# Maintain backward compatibility
DocumentProcessor = MainClass  # If class was renamed
```

### 2. **Use Dependency Injection**
```python
# Don't create tight coupling between split modules
class MainClass:
    def __init__(self, extractor=None, cleaner=None):
        self.extractor = extractor or DefaultExtractor()
        self.cleaner = cleaner or DefaultCleaner()
        
    @classmethod
    def create_default(cls):
        """Factory method for default configuration"""
        from .extractors import PDFExtractor
        from .cleaners import TextCleaner
        return cls(
            extractor=PDFExtractor(),
            cleaner=TextCleaner()
        )
```

### 3. **Clear Module Responsibilities**
```python
# Each module should have ONE clear responsibility

# extractors.py - ONLY text extraction
class PDFExtractor:
    def extract_text(self, pdf_path: str) -> str: ...
    def extract_metadata(self, pdf_path: str) -> dict: ...

# cleaners.py - ONLY text cleaning  
class TextCleaner:
    def clean_text(self, text: str) -> str: ...
    def normalize_whitespace(self, text: str) -> str: ...

# validators.py - ONLY validation
class TextValidator:
    def is_valid_astrological_text(self, text: str) -> bool: ...
    def check_minimum_quality(self, text: str) -> bool: ...
```

### 4. **Proper Import Structure**
```python
# Use relative imports within the package
from .base import BaseExtractor
from ..models import AstrologicalRule
from ...config import get_config

# Use absolute imports for external dependencies
from pathlib import Path
import sqlite3
from dataclasses import dataclass
```

## ğŸš¨ Auto-Split Triggers

### When Cursor Should Suggest Splitting:

1. **Line Count Trigger**: File approaches 300 lines
2. **Class Size Trigger**: Single class exceeds 150 lines
3. **Function Count Trigger**: More than 15 functions in one file
4. **Complexity Trigger**: Multiple unrelated responsibilities detected
5. **Import Count Trigger**: More than 20 imports (suggests too many dependencies)

### Split Suggestion Format:
```
ğŸ”„ REFACTOR SUGGESTION: This file has grown to 320 lines.
Consider splitting into:

1. core.py - Main class and essential methods (120 lines)
2. processors.py - Processing methods (90 lines)  
3. validators.py - Validation logic (70 lines)
4. utils.py - Helper functions (40 lines)

Would you like me to help create this modular structure?
```

## ğŸ“‹ Code Organization Principles

### 1. **Single Responsibility Per File**
- One main class or one group of related functions per file
- Clear, descriptive file names that indicate purpose
- No mixing of concerns (data access + business logic + presentation)

### 2. **Logical Grouping**
```python
# Group related functionality together
models/          # Data structures and schemas
â”œâ”€â”€ rules.py     # Rule-related models
â”œâ”€â”€ charts.py    # Chart-related models
â””â”€â”€ sources.py   # Source-related models

services/        # Business logic
â”œâ”€â”€ extraction.py    # Rule extraction service
â”œâ”€â”€ interpretation.py # Chart interpretation service
â””â”€â”€ validation.py    # Validation services

repositories/    # Data access
â”œâ”€â”€ rule_repo.py     # Rule database operations
â”œâ”€â”€ source_repo.py   # Source management
â””â”€â”€ chart_repo.py    # Chart storage
```

### 3. **Dependency Direction**
```
High Level â†’ Low Level
Services â†’ Repositories â†’ Models
CLI â†’ Services â†’ Repositories
```

### 4. **Interface Segregation**
```python
# Create focused interfaces instead of monolithic ones
class RuleExtractor(Protocol):
    def extract_rules(self, text: str) -> List[AstrologicalRule]: ...

class ConfidenceScorer(Protocol):
    def score_rule(self, rule: AstrologicalRule) -> float: ...

class RuleValidator(Protocol):
    def validate_rule(self, rule: AstrologicalRule) -> bool: ...
```
## ğŸ” File Review Checklist

Before accepting any file, check:
- [ ] **Line count < 300**: File is within size limits
- [ ] **Single responsibility**: File has one clear purpose  
- [ ] **Clear naming**: File name reflects its contents
- [ ] **Proper imports**: No circular dependencies
- [ ] **Documentation**: Classes and functions have docstrings
- [ ] **Type hints**: All function signatures have types
- [ ] **Error handling**: Appropriate exception handling
- [ ] **Testing**: File structure supports easy testing

## ğŸ› ï¸ Refactoring Workflow

### Step 1: Identify Split Points
```python
# Look for natural boundaries:
# - Different classes
# - Groups of related functions
# - Different concerns (validation vs processing)
# - Different abstraction levels
```

### Step 2: Create Module Structure
```python
# Create package directory
mkdir new_module
touch new_module/__init__.py

# Move code to logical files
# Update imports
# Test functionality
```

### Step 3: Preserve Interface
```python
# Ensure external code still works
# Update __init__.py with proper exports
# Add deprecation warnings if needed
```

### Step 4: Update Tests
```python
# Update test imports
# Ensure test coverage is maintained
# Add integration tests for the new module structure
```

## ğŸ¯ Astrology AI Module Targets

### Current Large Files to Monitor:
1. **document_processor.py** - Watch for text extraction complexity
2. **rule_extractor.py** - Multiple extraction patterns and logic
3. **knowledge_base.py** - Database operations and search logic
4. **cli.py** - Multiple command implementations
5. **main.py** - Application orchestration

### Suggested Future Structure:
```
src/
â”œâ”€â”€ core/               # Core business logic
â”œâ”€â”€ data/               # Data models and schemas  
â”œâ”€â”€ services/           # Application services
â”œâ”€â”€ repositories/       # Data access layer
â”œâ”€â”€ processors/         # Text and document processing
â”œâ”€â”€ extractors/         # Rule extraction modules
â”œâ”€â”€ cli/               # Command-line interface modules
â”œâ”€â”€ utils/             # Utility functions
â””â”€â”€ config/            # Configuration management
```

## ğŸ’¡ Best Practices for Small Files

### 1. **Focus and Clarity**
- Each file should be easily understandable in 5 minutes
- Clear separation of concerns
- Minimal cognitive load

### 2. **Easy Testing**
- Small files are easier to test
- Clear dependencies make mocking easier
- Single responsibility makes test cases clearer

### 3. **Better Collaboration**
- Less merge conflicts
- Easier code reviews
- Clearer ownership of functionality

### 4. **Maintenance**
- Easier to debug and modify
- Lower risk of introducing bugs
- Simpler to understand and extend

## ğŸš€ Implementation Strategy

### Phase 1: Monitor and Warn
- Track file sizes during development
- Warn when files approach 300 lines
- Suggest split strategies

### Phase 2: Guided Refactoring
- Provide specific split suggestions
- Help create new module structures
- Ensure backward compatibility

### Phase 3: Automated Assistance
- Auto-generate module skeletons
- Suggest import updates
- Validate new structure

Remember: **Small, focused files lead to better architecture, easier testing, and more maintainable code.** Every split should make the code clearer and more organized, not more complex.
